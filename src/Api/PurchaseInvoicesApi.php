<?php
/**
 * PurchaseInvoicesApi
 * PHP version 5
 *
 * @category Class
 *
 * @author   Swagger Codegen team
 *
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Storecove API
 *
 * Storecove API
 *
 * OpenAPI spec version: 2.0.1
 * Contact: apisupport@storecove.nl
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Deegitalbe\LaravelTrustupIoStorecove\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Deegitalbe\LaravelTrustupIoStorecove\ApiException;
use Deegitalbe\LaravelTrustupIoStorecove\Configuration;
use Deegitalbe\LaravelTrustupIoStorecove\HeaderSelector;
use Deegitalbe\LaravelTrustupIoStorecove\ObjectSerializer;

/**
 * PurchaseInvoicesApi Class Doc Comment
 *
 * @category Class
 *
 * @author   Swagger Codegen team
 *
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PurchaseInvoicesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getInvoiceJson
     *
     * DEPRECATED. Get Purchase invoice data as JSON
     *
     * @param  string  $guid  The guid of the purchase invoice, from the webhook. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. (optional, default to 1970-01-01)
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoice
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceJson($guid, $pmv = '1.0', $version = '1970-01-01')
    {
        [$response] = $this->getInvoiceJsonWithHttpInfo($guid, $pmv, $version);

        return $response;
    }

    /**
     * Operation getInvoiceJsonWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data as JSON
     *
     * @param  string  $guid  The guid of the purchase invoice, from the webhook. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. (optional, default to 1970-01-01)
     * @return array of \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoice, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceJsonWithHttpInfo($guid, $pmv = '1.0', $version = '1970-01-01')
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoice';
        $request = $this->getInvoiceJsonRequest($guid, $pmv, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceJsonAsync
     *
     * DEPRECATED. Get Purchase invoice data as JSON
     *
     * @param  string  $guid  The guid of the purchase invoice, from the webhook. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceJsonAsync($guid, $pmv = '1.0', $version = '1970-01-01')
    {
        return $this->getInvoiceJsonAsyncWithHttpInfo($guid, $pmv, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceJsonAsyncWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data as JSON
     *
     * @param  string  $guid  The guid of the purchase invoice, from the webhook. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceJsonAsyncWithHttpInfo($guid, $pmv = '1.0', $version = '1970-01-01')
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoice';
        $request = $this->getInvoiceJsonRequest($guid, $pmv, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceJson'
     *
     * @param  string  $guid  The guid of the purchase invoice, from the webhook. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    protected function getInvoiceJsonRequest($guid, $pmv = '1.0', $version = '1970-01-01')
    {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getInvoiceJson'
            );
        }
        if ($version !== null && ! preg_match('/^d{4}-d{2}-d{2}$/', $version)) {
            throw new \InvalidArgumentException('invalid value for "version" when calling PurchaseInvoicesApi.getInvoiceJson, must conform to the pattern /^d{4}-d{2}-d{2}$/.');
        }

        $resourcePath = '/purchase_invoices/{guid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pmv !== null) {
            $queryParams['pmv'] = ObjectSerializer::toQueryValue($pmv);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version);
        }

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                '{'.'guid'.'}',
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceUbl
     *
     * DEPRECATED. Get Purchase invoice data in a selectable format
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. Note that \&quot;ubl\&quot; is deprecated. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. Only used for &#39;json&#39; packaging, not for &#39;original&#39;. (optional, default to 1970-01-01)
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUbl($guid, $packaging, $pmv = '1.0', $version = '1970-01-01')
    {
        [$response] = $this->getInvoiceUblWithHttpInfo($guid, $packaging, $pmv, $version);

        return $response;
    }

    /**
     * Operation getInvoiceUblWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data in a selectable format
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. Note that \&quot;ubl\&quot; is deprecated. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. Only used for &#39;json&#39; packaging, not for &#39;original&#39;. (optional, default to 1970-01-01)
     * @return array of \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblWithHttpInfo($guid, $packaging, $pmv = '1.0', $version = '1970-01-01')
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl';
        $request = $this->getInvoiceUblRequest($guid, $packaging, $pmv, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceUblAsync
     *
     * DEPRECATED. Get Purchase invoice data in a selectable format
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. Note that \&quot;ubl\&quot; is deprecated. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. Only used for &#39;json&#39; packaging, not for &#39;original&#39;. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblAsync($guid, $packaging, $pmv = '1.0', $version = '1970-01-01')
    {
        return $this->getInvoiceUblAsyncWithHttpInfo($guid, $packaging, $pmv, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceUblAsyncWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data in a selectable format
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. Note that \&quot;ubl\&quot; is deprecated. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. Only used for &#39;json&#39; packaging, not for &#39;original&#39;. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblAsyncWithHttpInfo($guid, $packaging, $pmv = '1.0', $version = '1970-01-01')
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl';
        $request = $this->getInvoiceUblRequest($guid, $packaging, $pmv, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceUbl'
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. Note that \&quot;ubl\&quot; is deprecated. (required)
     * @param  string  $pmv  DEPRECATED. The PaymentMeans version. The default (and deprecated) version 1.0 will give BankPaymentMean, DirectDebitPaymentMean, CardPaymentMean, NppPaymentMean, SeBankGiroPaymentMean, SePlusGiroPaymentMean, SgCardPaymentMean, SgGiroPaymentMean, SgPaynowPaymentMean.  Version 2.0 deprecates BankPaymentMean (now CreditTransferPaymentMean), CardPaymentMean (now CreditCardPaymentMean), NppPaymentMean (now AunzNppPayidPaymentMean), SeBankGiroPaymentMean (now SeBankgiroPaymentMean  -- note the lower &#39;g&#39; in &#39;bankgiro&#39;). It also adds OnlinePaymentServicePaymentMean, StandingAgreementPaymentMean, AunzNppPaytoPaymentMean, AunzBpayPaymentMean, AunzPostbillpayPaymentMean, AunzUriPaymentMean. (optional, default to 1.0)
     * @param  string  $version  The JSON content version date. The default is &#39;1970-01-01&#39; meaning you get all deprecated elements since nothing was deprecated before that ;). If you do not want deprecated elements, use a later date. Do not use a dynamic date, because that means when we deprecate elements they will disappear from our responses. Only used for &#39;json&#39; packaging, not for &#39;original&#39;. (optional, default to 1970-01-01)
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    protected function getInvoiceUblRequest($guid, $packaging, $pmv = '1.0', $version = '1970-01-01')
    {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getInvoiceUbl'
            );
        }
        // verify the required parameter 'packaging' is set
        if ($packaging === null || (is_array($packaging) && count($packaging) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packaging when calling getInvoiceUbl'
            );
        }
        if ($version !== null && ! preg_match('/^d{4}-d{2}-d{2}$/', $version)) {
            throw new \InvalidArgumentException('invalid value for "version" when calling PurchaseInvoicesApi.getInvoiceUbl, must conform to the pattern /^d{4}-d{2}-d{2}$/.');
        }

        $resourcePath = '/purchase_invoices/{guid}/{packaging}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pmv !== null) {
            $queryParams['pmv'] = ObjectSerializer::toQueryValue($pmv);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version);
        }

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                '{'.'guid'.'}',
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($packaging !== null) {
            $resourcePath = str_replace(
                '{'.'packaging'.'}',
                ObjectSerializer::toPathValue($packaging),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceUblVersioned
     *
     * DEPRECATED. Get Purchase invoice data as JSON with a Base64-encoded UBL string in the specified version
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. (required)
     * @param  string  $package_version  The version of the package. (required)
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblVersioned($guid, $packaging, $package_version)
    {
        [$response] = $this->getInvoiceUblVersionedWithHttpInfo($guid, $packaging, $package_version);

        return $response;
    }

    /**
     * Operation getInvoiceUblVersionedWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data as JSON with a Base64-encoded UBL string in the specified version
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. (required)
     * @param  string  $package_version  The version of the package. (required)
     * @return array of \Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \Deegitalbe\LaravelTrustupIoStorecove\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblVersionedWithHttpInfo($guid, $packaging, $package_version)
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl';
        $request = $this->getInvoiceUblVersionedRequest($guid, $packaging, $package_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceUblVersionedAsync
     *
     * DEPRECATED. Get Purchase invoice data as JSON with a Base64-encoded UBL string in the specified version
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. (required)
     * @param  string  $package_version  The version of the package. (required)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblVersionedAsync($guid, $packaging, $package_version)
    {
        return $this->getInvoiceUblVersionedAsyncWithHttpInfo($guid, $packaging, $package_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceUblVersionedAsyncWithHttpInfo
     *
     * DEPRECATED. Get Purchase invoice data as JSON with a Base64-encoded UBL string in the specified version
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. (required)
     * @param  string  $package_version  The version of the package. (required)
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getInvoiceUblVersionedAsyncWithHttpInfo($guid, $packaging, $package_version)
    {
        $returnType = '\Deegitalbe\LaravelTrustupIoStorecove\Model\PurchaseInvoiceUbl';
        $request = $this->getInvoiceUblVersionedRequest($guid, $packaging, $package_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceUblVersioned'
     *
     * @param  string  $guid  purchase invoice guid (required)
     * @param  string  $packaging  How to package the purchase invoice. (required)
     * @param  string  $package_version  The version of the package. (required)
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    protected function getInvoiceUblVersionedRequest($guid, $packaging, $package_version)
    {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getInvoiceUblVersioned'
            );
        }
        // verify the required parameter 'packaging' is set
        if ($packaging === null || (is_array($packaging) && count($packaging) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $packaging when calling getInvoiceUblVersioned'
            );
        }
        // verify the required parameter 'package_version' is set
        if ($package_version === null || (is_array($package_version) && count($package_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $package_version when calling getInvoiceUblVersioned'
            );
        }

        $resourcePath = '/purchase_invoices/{guid}/{packaging}/{package_version}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                '{'.'guid'.'}',
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($packaging !== null) {
            $resourcePath = str_replace(
                '{'.'packaging'.'}',
                ObjectSerializer::toPathValue($packaging),
                $resourcePath
            );
        }
        // path params
        if ($package_version !== null) {
            $resourcePath = str_replace(
                '{'.'package_version'.'}',
                ObjectSerializer::toPathValue($package_version),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue,
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        return new Request(
            'GET',
            $this->config->getHost().$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @return array of http client options
     *
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (! $options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        return $options;
    }
}
