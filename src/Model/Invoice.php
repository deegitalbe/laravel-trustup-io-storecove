<?php
/**
 * Invoice
 *
 * PHP version 5
 *
 * @category Class
 *
 * @author   Swagger Codegen team
 *
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Storecove API
 *
 * Storecove API
 *
 * OpenAPI spec version: 2.0.1
 * Contact: apisupport@storecove.nl
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Deegitalbe\LaravelTrustupIoStorecove\Model;

use ArrayAccess;
use Swagger\Client\ObjectSerializer;

/**
 * Invoice Class Doc Comment
 *
 * @category Class
 *
 * @description The invoice to send. Provide either invoice, or invoiceData, but not both.
 *
 * @author   Swagger Codegen team
 *
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Invoice implements ArrayAccess, ModelInterface
{
    const DISCRIMINATOR = null;

    /**
     * The original name of the model.
     *
     * @var string
     */
    protected static $swaggerModelName = 'Invoice';

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerTypes = [
        'accounting_cost' => 'string',
        'accounting_currency_exchange_rate' => 'float',
        'accounting_currency_taxable_amount' => 'float',
        'accounting_currency_tax_amount' => 'float',
        'accounting_currency_tax_amount_currency' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode',
        'accounting_customer_party' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingCustomerParty',
        'payee_party' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\PayeeParty',
        'accounting_supplier_party' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingSupplierParty',
        'allowance_charges' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\AllowanceCharge[]',
        'amount_including_tax' => 'float',
        'amount_including_vat' => 'float',
        'attachments' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\Attachment[]',
        'consumer_tax_mode' => 'bool',
        'delivery' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\Delivery',
        'delivery_terms' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\DeliveryTerms',
        'document_currency_code' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode',
        'due_date' => 'string',
        'invoice_lines' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\InvoiceLine[]',
        'invoice_number' => 'string',
        'invoice_period' => 'string',
        'issue_date' => 'string',
        'issue_reasons' => 'string[]',
        'issue_time' => 'string',
        'note' => 'string',
        'payable_rounding_amount' => 'float',
        'payment_means_array' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentMeans[]',
        'payment_terms' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentTerms',
        'preferred_invoice_type' => 'string',
        'prepaid_amount' => 'float',
        'price_mode' => 'string',
        'references' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\Reference[]',
        'self_billing_mode' => 'bool',
        'sub_type' => 'string',
        'tax_point_date' => 'string',
        'tax_subtotals' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\TaxSubtotal[]',
        'tax_system' => 'string',
        'taxes_duties_fees' => '\Deegitalbe\LaravelTrustupIoStorecove\Model\Tax[]',
        'time_zone' => 'string',
        'transaction_type' => 'string',
        'ubl_extensions' => 'string[]',
        'x2y' => 'string',
        'vat_reverse_charge' => 'bool',
        'tax_exempt_reason' => 'string',
        'invoice_type' => 'string',
        'buyer_reference' => 'string',
        'order_reference' => 'string',
        'sales_order_id' => 'string',
        'billing_reference' => 'string',
        'contract_document_reference' => 'string',
        'project_reference' => 'string',
        'payment_means_iban' => 'string',
        'payment_means_bic' => 'string',
        'payment_means_code' => 'string',
        'payment_means_payment_id' => 'string',
    ];

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @var string[]
     */
    protected static $swaggerFormats = [
        'accounting_cost' => null,
        'accounting_currency_exchange_rate' => null,
        'accounting_currency_taxable_amount' => null,
        'accounting_currency_tax_amount' => null,
        'accounting_currency_tax_amount_currency' => null,
        'accounting_customer_party' => null,
        'payee_party' => null,
        'accounting_supplier_party' => null,
        'allowance_charges' => null,
        'amount_including_tax' => null,
        'amount_including_vat' => null,
        'attachments' => null,
        'consumer_tax_mode' => null,
        'delivery' => null,
        'delivery_terms' => null,
        'document_currency_code' => null,
        'due_date' => null,
        'invoice_lines' => null,
        'invoice_number' => null,
        'invoice_period' => null,
        'issue_date' => null,
        'issue_reasons' => null,
        'issue_time' => null,
        'note' => null,
        'payable_rounding_amount' => null,
        'payment_means_array' => null,
        'payment_terms' => null,
        'preferred_invoice_type' => null,
        'prepaid_amount' => null,
        'price_mode' => null,
        'references' => null,
        'self_billing_mode' => null,
        'sub_type' => null,
        'tax_point_date' => null,
        'tax_subtotals' => null,
        'tax_system' => null,
        'taxes_duties_fees' => null,
        'time_zone' => null,
        'transaction_type' => null,
        'ubl_extensions' => null,
        'x2y' => null,
        'vat_reverse_charge' => null,
        'tax_exempt_reason' => null,
        'invoice_type' => null,
        'buyer_reference' => null,
        'order_reference' => null,
        'sales_order_id' => null,
        'billing_reference' => null,
        'contract_document_reference' => null,
        'project_reference' => null,
        'payment_means_iban' => null,
        'payment_means_bic' => null,
        'payment_means_code' => null,
        'payment_means_payment_id' => null,
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'accounting_cost' => 'accountingCost',
        'accounting_currency_exchange_rate' => 'accountingCurrencyExchangeRate',
        'accounting_currency_taxable_amount' => 'accountingCurrencyTaxableAmount',
        'accounting_currency_tax_amount' => 'accountingCurrencyTaxAmount',
        'accounting_currency_tax_amount_currency' => 'accountingCurrencyTaxAmountCurrency',
        'accounting_customer_party' => 'accountingCustomerParty',
        'payee_party' => 'payeeParty',
        'accounting_supplier_party' => 'accountingSupplierParty',
        'allowance_charges' => 'allowanceCharges',
        'amount_including_tax' => 'amountIncludingTax',
        'amount_including_vat' => 'amountIncludingVat',
        'attachments' => 'attachments',
        'consumer_tax_mode' => 'consumerTaxMode',
        'delivery' => 'delivery',
        'delivery_terms' => 'deliveryTerms',
        'document_currency_code' => 'documentCurrencyCode',
        'due_date' => 'dueDate',
        'invoice_lines' => 'invoiceLines',
        'invoice_number' => 'invoiceNumber',
        'invoice_period' => 'invoicePeriod',
        'issue_date' => 'issueDate',
        'issue_reasons' => 'issueReasons',
        'issue_time' => 'issueTime',
        'note' => 'note',
        'payable_rounding_amount' => 'payableRoundingAmount',
        'payment_means_array' => 'paymentMeansArray',
        'payment_terms' => 'paymentTerms',
        'preferred_invoice_type' => 'preferredInvoiceType',
        'prepaid_amount' => 'prepaidAmount',
        'price_mode' => 'priceMode',
        'references' => 'references',
        'self_billing_mode' => 'selfBillingMode',
        'sub_type' => 'subType',
        'tax_point_date' => 'taxPointDate',
        'tax_subtotals' => 'taxSubtotals',
        'tax_system' => 'taxSystem',
        'taxes_duties_fees' => 'taxesDutiesFees',
        'time_zone' => 'timeZone',
        'transaction_type' => 'transactionType',
        'ubl_extensions' => 'ublExtensions',
        'x2y' => 'x2y',
        'vat_reverse_charge' => 'vatReverseCharge',
        'tax_exempt_reason' => 'taxExemptReason',
        'invoice_type' => 'invoiceType',
        'buyer_reference' => 'buyerReference',
        'order_reference' => 'orderReference',
        'sales_order_id' => 'salesOrderId',
        'billing_reference' => 'billingReference',
        'contract_document_reference' => 'contractDocumentReference',
        'project_reference' => 'projectReference',
        'payment_means_iban' => 'paymentMeansIban',
        'payment_means_bic' => 'paymentMeansBic',
        'payment_means_code' => 'paymentMeansCode',
        'payment_means_payment_id' => 'paymentMeansPaymentId',
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'accounting_cost' => 'setAccountingCost',
        'accounting_currency_exchange_rate' => 'setAccountingCurrencyExchangeRate',
        'accounting_currency_taxable_amount' => 'setAccountingCurrencyTaxableAmount',
        'accounting_currency_tax_amount' => 'setAccountingCurrencyTaxAmount',
        'accounting_currency_tax_amount_currency' => 'setAccountingCurrencyTaxAmountCurrency',
        'accounting_customer_party' => 'setAccountingCustomerParty',
        'payee_party' => 'setPayeeParty',
        'accounting_supplier_party' => 'setAccountingSupplierParty',
        'allowance_charges' => 'setAllowanceCharges',
        'amount_including_tax' => 'setAmountIncludingTax',
        'amount_including_vat' => 'setAmountIncludingVat',
        'attachments' => 'setAttachments',
        'consumer_tax_mode' => 'setConsumerTaxMode',
        'delivery' => 'setDelivery',
        'delivery_terms' => 'setDeliveryTerms',
        'document_currency_code' => 'setDocumentCurrencyCode',
        'due_date' => 'setDueDate',
        'invoice_lines' => 'setInvoiceLines',
        'invoice_number' => 'setInvoiceNumber',
        'invoice_period' => 'setInvoicePeriod',
        'issue_date' => 'setIssueDate',
        'issue_reasons' => 'setIssueReasons',
        'issue_time' => 'setIssueTime',
        'note' => 'setNote',
        'payable_rounding_amount' => 'setPayableRoundingAmount',
        'payment_means_array' => 'setPaymentMeansArray',
        'payment_terms' => 'setPaymentTerms',
        'preferred_invoice_type' => 'setPreferredInvoiceType',
        'prepaid_amount' => 'setPrepaidAmount',
        'price_mode' => 'setPriceMode',
        'references' => 'setReferences',
        'self_billing_mode' => 'setSelfBillingMode',
        'sub_type' => 'setSubType',
        'tax_point_date' => 'setTaxPointDate',
        'tax_subtotals' => 'setTaxSubtotals',
        'tax_system' => 'setTaxSystem',
        'taxes_duties_fees' => 'setTaxesDutiesFees',
        'time_zone' => 'setTimeZone',
        'transaction_type' => 'setTransactionType',
        'ubl_extensions' => 'setUblExtensions',
        'x2y' => 'setX2y',
        'vat_reverse_charge' => 'setVatReverseCharge',
        'tax_exempt_reason' => 'setTaxExemptReason',
        'invoice_type' => 'setInvoiceType',
        'buyer_reference' => 'setBuyerReference',
        'order_reference' => 'setOrderReference',
        'sales_order_id' => 'setSalesOrderId',
        'billing_reference' => 'setBillingReference',
        'contract_document_reference' => 'setContractDocumentReference',
        'project_reference' => 'setProjectReference',
        'payment_means_iban' => 'setPaymentMeansIban',
        'payment_means_bic' => 'setPaymentMeansBic',
        'payment_means_code' => 'setPaymentMeansCode',
        'payment_means_payment_id' => 'setPaymentMeansPaymentId',
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'accounting_cost' => 'getAccountingCost',
        'accounting_currency_exchange_rate' => 'getAccountingCurrencyExchangeRate',
        'accounting_currency_taxable_amount' => 'getAccountingCurrencyTaxableAmount',
        'accounting_currency_tax_amount' => 'getAccountingCurrencyTaxAmount',
        'accounting_currency_tax_amount_currency' => 'getAccountingCurrencyTaxAmountCurrency',
        'accounting_customer_party' => 'getAccountingCustomerParty',
        'payee_party' => 'getPayeeParty',
        'accounting_supplier_party' => 'getAccountingSupplierParty',
        'allowance_charges' => 'getAllowanceCharges',
        'amount_including_tax' => 'getAmountIncludingTax',
        'amount_including_vat' => 'getAmountIncludingVat',
        'attachments' => 'getAttachments',
        'consumer_tax_mode' => 'getConsumerTaxMode',
        'delivery' => 'getDelivery',
        'delivery_terms' => 'getDeliveryTerms',
        'document_currency_code' => 'getDocumentCurrencyCode',
        'due_date' => 'getDueDate',
        'invoice_lines' => 'getInvoiceLines',
        'invoice_number' => 'getInvoiceNumber',
        'invoice_period' => 'getInvoicePeriod',
        'issue_date' => 'getIssueDate',
        'issue_reasons' => 'getIssueReasons',
        'issue_time' => 'getIssueTime',
        'note' => 'getNote',
        'payable_rounding_amount' => 'getPayableRoundingAmount',
        'payment_means_array' => 'getPaymentMeansArray',
        'payment_terms' => 'getPaymentTerms',
        'preferred_invoice_type' => 'getPreferredInvoiceType',
        'prepaid_amount' => 'getPrepaidAmount',
        'price_mode' => 'getPriceMode',
        'references' => 'getReferences',
        'self_billing_mode' => 'getSelfBillingMode',
        'sub_type' => 'getSubType',
        'tax_point_date' => 'getTaxPointDate',
        'tax_subtotals' => 'getTaxSubtotals',
        'tax_system' => 'getTaxSystem',
        'taxes_duties_fees' => 'getTaxesDutiesFees',
        'time_zone' => 'getTimeZone',
        'transaction_type' => 'getTransactionType',
        'ubl_extensions' => 'getUblExtensions',
        'x2y' => 'getX2y',
        'vat_reverse_charge' => 'getVatReverseCharge',
        'tax_exempt_reason' => 'getTaxExemptReason',
        'invoice_type' => 'getInvoiceType',
        'buyer_reference' => 'getBuyerReference',
        'order_reference' => 'getOrderReference',
        'sales_order_id' => 'getSalesOrderId',
        'billing_reference' => 'getBillingReference',
        'contract_document_reference' => 'getContractDocumentReference',
        'project_reference' => 'getProjectReference',
        'payment_means_iban' => 'getPaymentMeansIban',
        'payment_means_bic' => 'getPaymentMeansBic',
        'payment_means_code' => 'getPaymentMeansCode',
        'payment_means_payment_id' => 'getPaymentMeansPaymentId',
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const PREFERRED_INVOICE_TYPE_AUTODETECT = 'prefer_autodetect';

    const PREFERRED_INVOICE_TYPE_INVOICE = 'prefer_invoice';

    const PREFERRED_INVOICE_TYPE_CREDITNOTE = 'prefer_creditnote';

    const PREFERRED_INVOICE_TYPE_DEBITNOTE = 'prefer_debitnote';

    const PREFERRED_INVOICE_TYPE_REFUNDNOTE = 'prefer_refundnote';

    const PREFERRED_INVOICE_TYPE_CORRECTED_INVOICE = 'prefer_corrected_invoice';

    const PREFERRED_INVOICE_TYPE_IT_TD02 = 'prefer_it_td02';

    const PREFERRED_INVOICE_TYPE_IT_TD19 = 'prefer_it_td19';

    const PREFERRED_INVOICE_TYPE_IT_TD24 = 'prefer_it_td24';

    const PRICE_MODE_NET = 'price_mode_net';

    const PRICE_MODE_GROSS = 'price_mode_gross';

    const SUB_TYPE_INVOICE = 'invoice';

    const SUB_TYPE_CREDITNOTE = 'creditnote';

    const SUB_TYPE_DEBITNOTE = 'debitnote';

    const SUB_TYPE_CORRECTIONINVOICE = 'correctioninvoice';

    const SUB_TYPE_SELFBILLING = 'selfbilling';

    const TAX_SYSTEM_AMOUNTS = 'tax_line_amounts';

    const TAX_SYSTEM_PERCENTAGES = 'tax_line_percentages';

    const TRANSACTION_TYPE_B2B = 'b2b';

    const TRANSACTION_TYPE_SEZWP = 'sezwp';

    const TRANSACTION_TYPE_SEZWOP = 'sezwop';

    const TRANSACTION_TYPE_EXPWP = 'expwp';

    const TRANSACTION_TYPE_EXPWOP = 'expwop';

    const TRANSACTION_TYPE_DEXP = 'dexp';

    const X2Y_B2B = 'b2b';

    const X2Y_B2G = 'b2g';

    const X2Y_B2C = 'b2c';

    const X2Y_B2B_SEZ = 'b2b_sez';

    const X2Y_PETTY_CASH = 'petty_cash';

    const X2Y_B2C_POINT_OF_SALE = 'b2c_point_of_sale';

    const X2Y_B2C_SIMPLIFIED_TAX_INVOICE = 'b2c_simplified_tax_invoice';

    const X2Y_B2C_PETTY_CASH = 'b2c_petty_cash';

    const TAX_EXEMPT_REASON_EXPORT = 'export';

    const TAX_EXEMPT_REASON_REVERSE_CHARGE = 'reverse_charge';

    const TAX_EXEMPT_REASON_ZERO_RATED = 'zero_rated';

    const TAX_EXEMPT_REASON_EXEMPT = 'exempt';

    const TAX_EXEMPT_REASON_OUTSIDE_SCOPE = 'outside_scope';

    const TAX_EXEMPT_REASON_INTRA_COMMUNITY = 'intra_community';

    const INVOICE_TYPE__380 = '380';

    const INVOICE_TYPE__381 = '381';

    const INVOICE_TYPE__383 = '383';

    const INVOICE_TYPE__384 = '384';

    const INVOICE_TYPE__389 = '389';

    const PAYMENT_MEANS_CODE_ONLINE_PAYMENT_SERVICE = 'online_payment_service';

    const PAYMENT_MEANS_CODE_BANK_CARD = 'bank_card';

    const PAYMENT_MEANS_CODE_DIRECT_DEBIT = 'direct_debit';

    const PAYMENT_MEANS_CODE_STANDING_AGREEMENT = 'standing_agreement';

    const PAYMENT_MEANS_CODE_CREDIT_TRANSFER = 'credit_transfer';

    const PAYMENT_MEANS_CODE_SE_BANKGIRO = 'se_bankgiro';

    const PAYMENT_MEANS_CODE_SE_PLUSGIRO = 'se_plusgiro';

    const PAYMENT_MEANS_CODE_AUNZ_NPP = 'aunz_npp';

    const PAYMENT_MEANS_CODE_EMPTY = '';

    const PAYMENT_MEANS_CODE__1 = '1';

    const PAYMENT_MEANS_CODE__30 = '30';

    const PAYMENT_MEANS_CODE__31 = '31';

    const PAYMENT_MEANS_CODE__42 = '42';

    const PAYMENT_MEANS_CODE__48 = '48';

    const PAYMENT_MEANS_CODE__49 = '49';

    const PAYMENT_MEANS_CODE__57 = '57';

    const PAYMENT_MEANS_CODE__58 = '58';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPreferredInvoiceTypeAllowableValues()
    {
        return [
            self::PREFERRED_INVOICE_TYPE_AUTODETECT,
            self::PREFERRED_INVOICE_TYPE_INVOICE,
            self::PREFERRED_INVOICE_TYPE_CREDITNOTE,
            self::PREFERRED_INVOICE_TYPE_DEBITNOTE,
            self::PREFERRED_INVOICE_TYPE_REFUNDNOTE,
            self::PREFERRED_INVOICE_TYPE_CORRECTED_INVOICE,
            self::PREFERRED_INVOICE_TYPE_IT_TD02,
            self::PREFERRED_INVOICE_TYPE_IT_TD19,
            self::PREFERRED_INVOICE_TYPE_IT_TD24,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPriceModeAllowableValues()
    {
        return [
            self::PRICE_MODE_NET,
            self::PRICE_MODE_GROSS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSubTypeAllowableValues()
    {
        return [
            self::SUB_TYPE_INVOICE,
            self::SUB_TYPE_CREDITNOTE,
            self::SUB_TYPE_DEBITNOTE,
            self::SUB_TYPE_CORRECTIONINVOICE,
            self::SUB_TYPE_SELFBILLING,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTaxSystemAllowableValues()
    {
        return [
            self::TAX_SYSTEM_AMOUNTS,
            self::TAX_SYSTEM_PERCENTAGES,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTransactionTypeAllowableValues()
    {
        return [
            self::TRANSACTION_TYPE_B2B,
            self::TRANSACTION_TYPE_SEZWP,
            self::TRANSACTION_TYPE_SEZWOP,
            self::TRANSACTION_TYPE_EXPWP,
            self::TRANSACTION_TYPE_EXPWOP,
            self::TRANSACTION_TYPE_DEXP,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getX2yAllowableValues()
    {
        return [
            self::X2Y_B2B,
            self::X2Y_B2G,
            self::X2Y_B2C,
            self::X2Y_B2B_SEZ,
            self::X2Y_PETTY_CASH,
            self::X2Y_B2C_POINT_OF_SALE,
            self::X2Y_B2C_SIMPLIFIED_TAX_INVOICE,
            self::X2Y_B2C_PETTY_CASH,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTaxExemptReasonAllowableValues()
    {
        return [
            self::TAX_EXEMPT_REASON_EXPORT,
            self::TAX_EXEMPT_REASON_REVERSE_CHARGE,
            self::TAX_EXEMPT_REASON_ZERO_RATED,
            self::TAX_EXEMPT_REASON_EXEMPT,
            self::TAX_EXEMPT_REASON_OUTSIDE_SCOPE,
            self::TAX_EXEMPT_REASON_INTRA_COMMUNITY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInvoiceTypeAllowableValues()
    {
        return [
            self::INVOICE_TYPE__380,
            self::INVOICE_TYPE__381,
            self::INVOICE_TYPE__383,
            self::INVOICE_TYPE__384,
            self::INVOICE_TYPE__389,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentMeansCodeAllowableValues()
    {
        return [
            self::PAYMENT_MEANS_CODE_ONLINE_PAYMENT_SERVICE,
            self::PAYMENT_MEANS_CODE_BANK_CARD,
            self::PAYMENT_MEANS_CODE_DIRECT_DEBIT,
            self::PAYMENT_MEANS_CODE_STANDING_AGREEMENT,
            self::PAYMENT_MEANS_CODE_CREDIT_TRANSFER,
            self::PAYMENT_MEANS_CODE_SE_BANKGIRO,
            self::PAYMENT_MEANS_CODE_SE_PLUSGIRO,
            self::PAYMENT_MEANS_CODE_AUNZ_NPP,
            self::PAYMENT_MEANS_CODE_EMPTY,
            self::PAYMENT_MEANS_CODE__1,
            self::PAYMENT_MEANS_CODE__30,
            self::PAYMENT_MEANS_CODE__31,
            self::PAYMENT_MEANS_CODE__42,
            self::PAYMENT_MEANS_CODE__48,
            self::PAYMENT_MEANS_CODE__49,
            self::PAYMENT_MEANS_CODE__57,
            self::PAYMENT_MEANS_CODE__58,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param  mixed[]  $data  Associated array of property values
     *                         initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->container['accounting_cost'] = isset($data['accounting_cost']) ? $data['accounting_cost'] : null;
        $this->container['accounting_currency_exchange_rate'] = isset($data['accounting_currency_exchange_rate']) ? $data['accounting_currency_exchange_rate'] : null;
        $this->container['accounting_currency_taxable_amount'] = isset($data['accounting_currency_taxable_amount']) ? $data['accounting_currency_taxable_amount'] : null;
        $this->container['accounting_currency_tax_amount'] = isset($data['accounting_currency_tax_amount']) ? $data['accounting_currency_tax_amount'] : null;
        $this->container['accounting_currency_tax_amount_currency'] = isset($data['accounting_currency_tax_amount_currency']) ? $data['accounting_currency_tax_amount_currency'] : null;
        $this->container['accounting_customer_party'] = isset($data['accounting_customer_party']) ? $data['accounting_customer_party'] : null;
        $this->container['payee_party'] = isset($data['payee_party']) ? $data['payee_party'] : null;
        $this->container['accounting_supplier_party'] = isset($data['accounting_supplier_party']) ? $data['accounting_supplier_party'] : null;
        $this->container['allowance_charges'] = isset($data['allowance_charges']) ? $data['allowance_charges'] : null;
        $this->container['amount_including_tax'] = isset($data['amount_including_tax']) ? $data['amount_including_tax'] : null;
        $this->container['amount_including_vat'] = isset($data['amount_including_vat']) ? $data['amount_including_vat'] : null;
        $this->container['attachments'] = isset($data['attachments']) ? $data['attachments'] : null;
        $this->container['consumer_tax_mode'] = isset($data['consumer_tax_mode']) ? $data['consumer_tax_mode'] : false;
        $this->container['delivery'] = isset($data['delivery']) ? $data['delivery'] : null;
        $this->container['delivery_terms'] = isset($data['delivery_terms']) ? $data['delivery_terms'] : null;
        $this->container['document_currency_code'] = isset($data['document_currency_code']) ? $data['document_currency_code'] : null;
        $this->container['due_date'] = isset($data['due_date']) ? $data['due_date'] : null;
        $this->container['invoice_lines'] = isset($data['invoice_lines']) ? $data['invoice_lines'] : null;
        $this->container['invoice_number'] = isset($data['invoice_number']) ? $data['invoice_number'] : null;
        $this->container['invoice_period'] = isset($data['invoice_period']) ? $data['invoice_period'] : null;
        $this->container['issue_date'] = isset($data['issue_date']) ? $data['issue_date'] : null;
        $this->container['issue_reasons'] = isset($data['issue_reasons']) ? $data['issue_reasons'] : null;
        $this->container['issue_time'] = isset($data['issue_time']) ? $data['issue_time'] : null;
        $this->container['note'] = isset($data['note']) ? $data['note'] : null;
        $this->container['payable_rounding_amount'] = isset($data['payable_rounding_amount']) ? $data['payable_rounding_amount'] : null;
        $this->container['payment_means_array'] = isset($data['payment_means_array']) ? $data['payment_means_array'] : null;
        $this->container['payment_terms'] = isset($data['payment_terms']) ? $data['payment_terms'] : null;
        $this->container['preferred_invoice_type'] = isset($data['preferred_invoice_type']) ? $data['preferred_invoice_type'] : 'prefer_autodetect';
        $this->container['prepaid_amount'] = isset($data['prepaid_amount']) ? $data['prepaid_amount'] : null;
        $this->container['price_mode'] = isset($data['price_mode']) ? $data['price_mode'] : 'price_mode_net';
        $this->container['references'] = isset($data['references']) ? $data['references'] : null;
        $this->container['self_billing_mode'] = isset($data['self_billing_mode']) ? $data['self_billing_mode'] : false;
        $this->container['sub_type'] = isset($data['sub_type']) ? $data['sub_type'] : null;
        $this->container['tax_point_date'] = isset($data['tax_point_date']) ? $data['tax_point_date'] : null;
        $this->container['tax_subtotals'] = isset($data['tax_subtotals']) ? $data['tax_subtotals'] : null;
        $this->container['tax_system'] = isset($data['tax_system']) ? $data['tax_system'] : 'tax_line_amounts';
        $this->container['taxes_duties_fees'] = isset($data['taxes_duties_fees']) ? $data['taxes_duties_fees'] : null;
        $this->container['time_zone'] = isset($data['time_zone']) ? $data['time_zone'] : null;
        $this->container['transaction_type'] = isset($data['transaction_type']) ? $data['transaction_type'] : null;
        $this->container['ubl_extensions'] = isset($data['ubl_extensions']) ? $data['ubl_extensions'] : null;
        $this->container['x2y'] = isset($data['x2y']) ? $data['x2y'] : 'b2b';
        $this->container['vat_reverse_charge'] = isset($data['vat_reverse_charge']) ? $data['vat_reverse_charge'] : false;
        $this->container['tax_exempt_reason'] = isset($data['tax_exempt_reason']) ? $data['tax_exempt_reason'] : null;
        $this->container['invoice_type'] = isset($data['invoice_type']) ? $data['invoice_type'] : '380';
        $this->container['buyer_reference'] = isset($data['buyer_reference']) ? $data['buyer_reference'] : null;
        $this->container['order_reference'] = isset($data['order_reference']) ? $data['order_reference'] : null;
        $this->container['sales_order_id'] = isset($data['sales_order_id']) ? $data['sales_order_id'] : null;
        $this->container['billing_reference'] = isset($data['billing_reference']) ? $data['billing_reference'] : null;
        $this->container['contract_document_reference'] = isset($data['contract_document_reference']) ? $data['contract_document_reference'] : null;
        $this->container['project_reference'] = isset($data['project_reference']) ? $data['project_reference'] : null;
        $this->container['payment_means_iban'] = isset($data['payment_means_iban']) ? $data['payment_means_iban'] : null;
        $this->container['payment_means_bic'] = isset($data['payment_means_bic']) ? $data['payment_means_bic'] : null;
        $this->container['payment_means_code'] = isset($data['payment_means_code']) ? $data['payment_means_code'] : null;
        $this->container['payment_means_payment_id'] = isset($data['payment_means_payment_id']) ? $data['payment_means_payment_id'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (! is_null($this->container['accounting_cost']) && (mb_strlen($this->container['accounting_cost']) < 1)) {
            $invalidProperties[] = "invalid value for 'accounting_cost', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['accounting_customer_party'] === null) {
            $invalidProperties[] = "'accounting_customer_party' can't be null";
        }
        if (! is_null($this->container['due_date']) && ! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $this->container['due_date'])) {
            $invalidProperties[] = "invalid value for 'due_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if ($this->container['invoice_lines'] === null) {
            $invalidProperties[] = "'invoice_lines' can't be null";
        }
        if ($this->container['invoice_number'] === null) {
            $invalidProperties[] = "'invoice_number' can't be null";
        }
        if ((mb_strlen($this->container['invoice_number']) < 1)) {
            $invalidProperties[] = "invalid value for 'invoice_number', the character length must be bigger than or equal to 1.";
        }

        if (! is_null($this->container['invoice_period']) && ! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/', $this->container['invoice_period'])) {
            $invalidProperties[] = "invalid value for 'invoice_period', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if ($this->container['issue_date'] === null) {
            $invalidProperties[] = "'issue_date' can't be null";
        }
        if (! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $this->container['issue_date'])) {
            $invalidProperties[] = "invalid value for 'issue_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        if (! is_null($this->container['issue_time']) && ! preg_match('/^[0-9]{2}:[0-9]{2}:[0-9]{2}$/', $this->container['issue_time'])) {
            $invalidProperties[] = "invalid value for 'issue_time', must be conform to the pattern /^[0-9]{2}:[0-9]{2}:[0-9]{2}$/.";
        }

        $allowedValues = $this->getPreferredInvoiceTypeAllowableValues();
        if (! is_null($this->container['preferred_invoice_type']) && ! in_array($this->container['preferred_invoice_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'preferred_invoice_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPriceModeAllowableValues();
        if (! is_null($this->container['price_mode']) && ! in_array($this->container['price_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'price_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSubTypeAllowableValues();
        if (! is_null($this->container['sub_type']) && ! in_array($this->container['sub_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'sub_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (! is_null($this->container['tax_point_date']) && ! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $this->container['tax_point_date'])) {
            $invalidProperties[] = "invalid value for 'tax_point_date', must be conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.";
        }

        $allowedValues = $this->getTaxSystemAllowableValues();
        if (! is_null($this->container['tax_system']) && ! in_array($this->container['tax_system'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'tax_system', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (! is_null($this->container['time_zone']) && ! preg_match('/^[+-]\\d{4}$/', $this->container['time_zone'])) {
            $invalidProperties[] = "invalid value for 'time_zone', must be conform to the pattern /^[+-]\\d{4}$/.";
        }

        $allowedValues = $this->getTransactionTypeAllowableValues();
        if (! is_null($this->container['transaction_type']) && ! in_array($this->container['transaction_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'transaction_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getX2yAllowableValues();
        if (! is_null($this->container['x2y']) && ! in_array($this->container['x2y'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'x2y', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTaxExemptReasonAllowableValues();
        if (! is_null($this->container['tax_exempt_reason']) && ! in_array($this->container['tax_exempt_reason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'tax_exempt_reason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInvoiceTypeAllowableValues();
        if (! is_null($this->container['invoice_type']) && ! in_array($this->container['invoice_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'invoice_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (! is_null($this->container['payment_means_bic']) && ! preg_match('/^[A-Z]{6}[2-9A-Z][0-9A-NP-Z]([A-Z0-9]{3}|X{3})?$/', $this->container['payment_means_bic'])) {
            $invalidProperties[] = "invalid value for 'payment_means_bic', must be conform to the pattern /^[A-Z]{6}[2-9A-Z][0-9A-NP-Z]([A-Z0-9]{3}|X{3})?$/.";
        }

        $allowedValues = $this->getPaymentMeansCodeAllowableValues();
        if (! is_null($this->container['payment_means_code']) && ! in_array($this->container['payment_means_code'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'payment_means_code', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }

    /**
     * Gets accounting_cost
     *
     * @return string
     */
    public function getAccountingCost()
    {
        return $this->container['accounting_cost'];
    }

    /**
     * Sets accounting_cost
     *
     * @param  string  $accounting_cost  The buyer's accounting cost centre for this invoice, expressed as text.
     * @return $this
     */
    public function setAccountingCost($accounting_cost)
    {

        if (! is_null($accounting_cost) && (mb_strlen($accounting_cost) < 1)) {
            throw new \InvalidArgumentException('invalid length for $accounting_cost when calling Invoice., must be bigger than or equal to 1.');
        }

        $this->container['accounting_cost'] = $accounting_cost;

        return $this;
    }

    /**
     * Gets accounting_currency_exchange_rate
     *
     * @return float
     */
    public function getAccountingCurrencyExchangeRate()
    {
        return $this->container['accounting_currency_exchange_rate'];
    }

    /**
     * Sets accounting_currency_exchange_rate
     *
     * @param  float  $accounting_currency_exchange_rate  Rate at which the document currency must be multiplied to convert it into the accounting currency. If included, must be non-zero.
     * @return $this
     */
    public function setAccountingCurrencyExchangeRate($accounting_currency_exchange_rate)
    {
        $this->container['accounting_currency_exchange_rate'] = $accounting_currency_exchange_rate;

        return $this;
    }

    /**
     * Gets accounting_currency_taxable_amount
     *
     * @return float
     */
    public function getAccountingCurrencyTaxableAmount()
    {
        return $this->container['accounting_currency_taxable_amount'];
    }

    /**
     * Sets accounting_currency_taxable_amount
     *
     * @param  float  $accounting_currency_taxable_amount  The taxable amount in the accounting currency. If included, must be non-zero.
     * @return $this
     */
    public function setAccountingCurrencyTaxableAmount($accounting_currency_taxable_amount)
    {
        $this->container['accounting_currency_taxable_amount'] = $accounting_currency_taxable_amount;

        return $this;
    }

    /**
     * Gets accounting_currency_tax_amount
     *
     * @return float
     */
    public function getAccountingCurrencyTaxAmount()
    {
        return $this->container['accounting_currency_tax_amount'];
    }

    /**
     * Sets accounting_currency_tax_amount
     *
     * @param  float  $accounting_currency_tax_amount  The total amount of tax in the accounting currency. If included, must be non-zero.
     * @return $this
     */
    public function setAccountingCurrencyTaxAmount($accounting_currency_tax_amount)
    {
        $this->container['accounting_currency_tax_amount'] = $accounting_currency_tax_amount;

        return $this;
    }

    /**
     * Gets accounting_currency_tax_amount_currency
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode
     */
    public function getAccountingCurrencyTaxAmountCurrency()
    {
        return $this->container['accounting_currency_tax_amount_currency'];
    }

    /**
     * Sets accounting_currency_tax_amount_currency
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode  $accounting_currency_tax_amount_currency  The currency of the accountingCurrencyTaxAmount. This MUST be different from the documentCurrencyCode, since it makes no sense including this othterwise. Mandatory if accountingCurrencyTaxAmount is provided.
     * @return $this
     */
    public function setAccountingCurrencyTaxAmountCurrency($accounting_currency_tax_amount_currency)
    {
        $this->container['accounting_currency_tax_amount_currency'] = $accounting_currency_tax_amount_currency;

        return $this;
    }

    /**
     * Gets accounting_customer_party
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingCustomerParty
     */
    public function getAccountingCustomerParty()
    {
        return $this->container['accounting_customer_party'];
    }

    /**
     * Sets accounting_customer_party
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingCustomerParty  $accounting_customer_party  The party the invoice is sent to.
     * @return $this
     */
    public function setAccountingCustomerParty($accounting_customer_party)
    {
        $this->container['accounting_customer_party'] = $accounting_customer_party;

        return $this;
    }

    /**
     * Gets payee_party
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PayeeParty
     */
    public function getPayeeParty()
    {
        return $this->container['payee_party'];
    }

    /**
     * Sets payee_party
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\PayeeParty  $payee_party  The party to whom the invoice will be paid.
     * @return $this
     */
    public function setPayeeParty($payee_party)
    {
        $this->container['payee_party'] = $payee_party;

        return $this;
    }

    /**
     * Gets accounting_supplier_party
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingSupplierParty
     */
    public function getAccountingSupplierParty()
    {
        return $this->container['accounting_supplier_party'];
    }

    /**
     * Sets accounting_supplier_party
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\AccountingSupplierParty  $accounting_supplier_party  The party sending the invoice. When you are sending, most data for the AccountingSupplierParty is taken from the LegalEntity in the Storecove database, where your sender identity resides and has been validated. However, we provide a limited number of fields (mainly contact fields) here that you can specify on a document-by-document basis. For receiving, the full party object can be received.
     * @return $this
     */
    public function setAccountingSupplierParty($accounting_supplier_party)
    {
        $this->container['accounting_supplier_party'] = $accounting_supplier_party;

        return $this;
    }

    /**
     * Gets allowance_charges
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\AllowanceCharge[]
     */
    public function getAllowanceCharges()
    {
        return $this->container['allowance_charges'];
    }

    /**
     * Sets allowance_charges
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\AllowanceCharge[]  $allowance_charges  An array of allowance charges.
     * @return $this
     */
    public function setAllowanceCharges($allowance_charges)
    {
        $this->container['allowance_charges'] = $allowance_charges;

        return $this;
    }

    /**
     * Gets amount_including_tax
     *
     * @return float
     */
    public function getAmountIncludingTax()
    {
        return $this->container['amount_including_tax'];
    }

    /**
     * Sets amount_including_tax
     *
     * @param  float  $amount_including_tax  EXPERIMENTAL for sending. The amountIncludingTax is the payable amount, but not corrected for the prepaid amount.
     * @return $this
     */
    public function setAmountIncludingTax($amount_including_tax)
    {
        $this->container['amount_including_tax'] = $amount_including_tax;

        return $this;
    }

    /**
     * Gets amount_including_vat
     *
     * @return float
     */
    public function getAmountIncludingVat()
    {
        return $this->container['amount_including_vat'];
    }

    /**
     * Sets amount_including_vat
     *
     * @param  float  $amount_including_vat  The amountIncludingVat is payable amount, but not corrected for the prepaid amount. We encourage you to use the amountIncludingTax for sending. For receiving, always use amountIncludingTax.
     * @return $this
     */
    public function setAmountIncludingVat($amount_including_vat)
    {
        $this->container['amount_including_vat'] = $amount_including_vat;

        return $this;
    }

    /**
     * Gets attachments
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\Attachment[]
     */
    public function getAttachments()
    {
        return $this->container['attachments'];
    }

    /**
     * Sets attachments
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\Attachment[]  $attachments  An array of attachments. You may provide up to 10 attchments, but the total size must not exceed 100MB after Base64 encoding.
     * @return $this
     */
    public function setAttachments($attachments)
    {
        $this->container['attachments'] = $attachments;

        return $this;
    }

    /**
     * Gets consumer_tax_mode
     *
     * @return bool
     */
    public function getConsumerTaxMode()
    {
        return $this->container['consumer_tax_mode'];
    }

    /**
     * Sets consumer_tax_mode
     *
     * @param  bool  $consumer_tax_mode  Whether or not to process the invoice in consumer tax mode. In this mode, the VAT identifier of the sender will not be the default VAT identifier, but the one that matches with the country of the receiving consumer, if that additional VAT identifier for that country is available. These additional VAT identifiers need to be added to the sending LegalEntity by Storecove, so if you need to send invoices in this mode, please contact us. Not used for receiving.
     * @return $this
     */
    public function setConsumerTaxMode($consumer_tax_mode)
    {
        $this->container['consumer_tax_mode'] = $consumer_tax_mode;

        return $this;
    }

    /**
     * Gets delivery
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\Delivery
     */
    public function getDelivery()
    {
        return $this->container['delivery'];
    }

    /**
     * Sets delivery
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\Delivery  $delivery  The delivery of the invoice.
     * @return $this
     */
    public function setDelivery($delivery)
    {
        $this->container['delivery'] = $delivery;

        return $this;
    }

    /**
     * Gets delivery_terms
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\DeliveryTerms
     */
    public function getDeliveryTerms()
    {
        return $this->container['delivery_terms'];
    }

    /**
     * Sets delivery_terms
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\DeliveryTerms  $delivery_terms  The terms of delivery for the document. This is currently only used for MY LHDNM.
     * @return $this
     */
    public function setDeliveryTerms($delivery_terms)
    {
        $this->container['delivery_terms'] = $delivery_terms;

        return $this;
    }

    /**
     * Gets document_currency_code
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode
     */
    public function getDocumentCurrencyCode()
    {
        return $this->container['document_currency_code'];
    }

    /**
     * Sets document_currency_code
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\CurrencyCode  $document_currency_code  The documentCurrencyCode is the currency for the entire invoice. We currently do not support invoices in multiple currencies. If left out, will default to EUR
     * @return $this
     */
    public function setDocumentCurrencyCode($document_currency_code)
    {
        $this->container['document_currency_code'] = $document_currency_code;

        return $this;
    }

    /**
     * Gets due_date
     *
     * @return string
     */
    public function getDueDate()
    {
        return $this->container['due_date'];
    }

    /**
     * Sets due_date
     *
     * @param  string  $due_date  Format: yyyy-mm-dd.
     * @return $this
     */
    public function setDueDate($due_date)
    {

        if (! is_null($due_date) && (! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $due_date))) {
            throw new \InvalidArgumentException("invalid value for $due_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['due_date'] = $due_date;

        return $this;
    }

    /**
     * Gets invoice_lines
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\InvoiceLine[]
     */
    public function getInvoiceLines()
    {
        return $this->container['invoice_lines'];
    }

    /**
     * Sets invoice_lines
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\InvoiceLine[]  $invoice_lines  An array of invoice lines.
     * @return $this
     */
    public function setInvoiceLines($invoice_lines)
    {
        $this->container['invoice_lines'] = $invoice_lines;

        return $this;
    }

    /**
     * Gets invoice_number
     *
     * @return string
     */
    public function getInvoiceNumber()
    {
        return $this->container['invoice_number'];
    }

    /**
     * Sets invoice_number
     *
     * @param  string  $invoice_number  The invoice number you assigned to the invoice. The invoiceNumber should be unique for the legalEntityId and year of the issueDate. This means invoice numbers can be reused in different years, as is customary in some countries.
     * @return $this
     */
    public function setInvoiceNumber($invoice_number)
    {

        if ((mb_strlen($invoice_number) < 1)) {
            throw new \InvalidArgumentException('invalid length for $invoice_number when calling Invoice., must be bigger than or equal to 1.');
        }

        $this->container['invoice_number'] = $invoice_number;

        return $this;
    }

    /**
     * Gets invoice_period
     *
     * @return string
     */
    public function getInvoicePeriod()
    {
        return $this->container['invoice_period'];
    }

    /**
     * Sets invoice_period
     *
     * @param  string  $invoice_period  The period (or specific date) to which the invoice applies. Format: yyyy-mm-dd - yyyy-mm-dd.
     * @return $this
     */
    public function setInvoicePeriod($invoice_period)
    {

        if (! is_null($invoice_period) && (! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/', $invoice_period))) {
            throw new \InvalidArgumentException("invalid value for $invoice_period when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2} - [0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['invoice_period'] = $invoice_period;

        return $this;
    }

    /**
     * Gets issue_date
     *
     * @return string
     */
    public function getIssueDate()
    {
        return $this->container['issue_date'];
    }

    /**
     * Sets issue_date
     *
     * @param  string  $issue_date  Format: yyyy-mm-dd.
     * @return $this
     */
    public function setIssueDate($issue_date)
    {

        if ((! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $issue_date))) {
            throw new \InvalidArgumentException("invalid value for $issue_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['issue_date'] = $issue_date;

        return $this;
    }

    /**
     * Gets issue_reasons
     *
     * @return string[]
     */
    public function getIssueReasons()
    {
        return $this->container['issue_reasons'];
    }

    /**
     * Sets issue_reasons
     *
     * @param  string[]  $issue_reasons  An array reasons for issuing the invoice.
     * @return $this
     */
    public function setIssueReasons($issue_reasons)
    {
        $this->container['issue_reasons'] = $issue_reasons;

        return $this;
    }

    /**
     * Gets issue_time
     *
     * @return string
     */
    public function getIssueTime()
    {
        return $this->container['issue_time'];
    }

    /**
     * Sets issue_time
     *
     * @param  string  $issue_time  Format: hh:mm:ss
     * @return $this
     */
    public function setIssueTime($issue_time)
    {

        if (! is_null($issue_time) && (! preg_match('/^[0-9]{2}:[0-9]{2}:[0-9]{2}$/', $issue_time))) {
            throw new \InvalidArgumentException("invalid value for $issue_time when calling Invoice., must conform to the pattern /^[0-9]{2}:[0-9]{2}:[0-9]{2}$/.");
        }

        $this->container['issue_time'] = $issue_time;

        return $this;
    }

    /**
     * Gets note
     *
     * @return string
     */
    public function getNote()
    {
        return $this->container['note'];
    }

    /**
     * Sets note
     *
     * @param  string  $note  A note to add to the invoice
     * @return $this
     */
    public function setNote($note)
    {
        $this->container['note'] = $note;

        return $this;
    }

    /**
     * Gets payable_rounding_amount
     *
     * @return float
     */
    public function getPayableRoundingAmount()
    {
        return $this->container['payable_rounding_amount'];
    }

    /**
     * Sets payable_rounding_amount
     *
     * @param  float  $payable_rounding_amount  The rounding amount for the payable amount. This amount is calulated automatically from the invoiceLines, allowanceCharges and the taxSubtotals. If you provide this field, it must be exactly what we would have calculated. We recommend not using this field for sending. For receiving, it is always present.
     * @return $this
     */
    public function setPayableRoundingAmount($payable_rounding_amount)
    {
        $this->container['payable_rounding_amount'] = $payable_rounding_amount;

        return $this;
    }

    /**
     * Gets payment_means_array
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentMeans[]
     */
    public function getPaymentMeansArray()
    {
        return $this->container['payment_means_array'];
    }

    /**
     * Sets payment_means_array
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentMeans[]  $payment_means_array  An array of payment means (ways to pay the invoice).
     * @return $this
     */
    public function setPaymentMeansArray($payment_means_array)
    {
        $this->container['payment_means_array'] = $payment_means_array;

        return $this;
    }

    /**
     * Gets payment_terms
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentTerms
     */
    public function getPaymentTerms()
    {
        return $this->container['payment_terms'];
    }

    /**
     * Sets payment_terms
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\PaymentTerms  $payment_terms  The payment terms of the invoice.
     * @return $this
     */
    public function setPaymentTerms($payment_terms)
    {
        $this->container['payment_terms'] = $payment_terms;

        return $this;
    }

    /**
     * Gets preferred_invoice_type
     *
     * @return string
     */
    public function getPreferredInvoiceType()
    {
        return $this->container['preferred_invoice_type'];
    }

    /**
     * Sets preferred_invoice_type
     *
     * @param  string  $preferred_invoice_type  In autodetect mode, the choice is made by Storecove based on what is appropriate for the receiver and the receiver country, in combination with the invoice amount sign. If you wish to state a preference, use this field. It is not guaranteed that the preference will be used, since it depends also on the receiver's document capabilities. Only used for sending, not for receiving. For Peppol, only invoice and creditnote are supported. For LHDNM, also debitnote and refundnote are supported. Anything starting it_td* can only be used for SDI. Only used for sending, not present for receiving.
     * @return $this
     */
    public function setPreferredInvoiceType($preferred_invoice_type)
    {
        $allowedValues = $this->getPreferredInvoiceTypeAllowableValues();
        if (! is_null($preferred_invoice_type) && ! in_array($preferred_invoice_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'preferred_invoice_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['preferred_invoice_type'] = $preferred_invoice_type;

        return $this;
    }

    /**
     * Gets prepaid_amount
     *
     * @return float
     */
    public function getPrepaidAmount()
    {
        return $this->container['prepaid_amount'];
    }

    /**
     * Sets prepaid_amount
     *
     * @param  float  $prepaid_amount  The amount already paid. The amountInclucingTax - prepaidAmount is the amount remaining to be paid.
     * @return $this
     */
    public function setPrepaidAmount($prepaid_amount)
    {
        $this->container['prepaid_amount'] = $prepaid_amount;

        return $this;
    }

    /**
     * Gets price_mode
     *
     * @return string
     */
    public function getPriceMode()
    {
        return $this->container['price_mode'];
    }

    /**
     * Sets price_mode
     *
     * @param  string  $price_mode  The price mode. This is used to determine whether the prices are net or gross. Price Mode 'price_mode_gross' can only be used for sender countries ES, IT and PT, \"clearWithoutSending\": true and \"taxSystem\": \"tax_line_percentages\". Only used for sending, not present for receiving.
     * @return $this
     */
    public function setPriceMode($price_mode)
    {
        $allowedValues = $this->getPriceModeAllowableValues();
        if (! is_null($price_mode) && ! in_array($price_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'price_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['price_mode'] = $price_mode;

        return $this;
    }

    /**
     * Gets references
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\Reference[]
     */
    public function getReferences()
    {
        return $this->container['references'];
    }

    /**
     * Sets references
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\Reference[]  $references  An array of references to other documents. Note that many syntaxes do not support multiple references of the same type in which case they will be concatenated with ','. Also, not all syntaxes support all documentTypes.
     * @return $this
     */
    public function setReferences($references)
    {
        $this->container['references'] = $references;

        return $this;
    }

    /**
     * Gets self_billing_mode
     *
     * @return bool
     */
    public function getSelfBillingMode()
    {
        return $this->container['self_billing_mode'];
    }

    /**
     * Sets self_billing_mode
     *
     * @param  bool  $self_billing_mode  +++ <p>        There are two reasons for using self billing mode:</p><ol>        <li>                The buyer generated the invoice and it needs to be sent to the seller. When sending via Peppol, the receiver needs to support this by advertising a special \"self-billing\" document type. Otherwise, an email will be sent.        </li>        <li>                An invoice was received that needs to be reported as a purchase invoice to a tax authority.        </li></ol><p>        When sending in this mode the buyer (\"AccountingCustomerParty\") and the seller (\"AccountingSupplierParty\") are automatically switched. That means you still provide the same legalEntityId for the sender (who is now the buyer) and the accountingCustomerParty object is still the receiver (but it is now the seller). That means no changes to the JSON are necessary.</p><p>        When reporting a received invoice to a tax authority, set the \"clearWithoutSending\": true flag. Otherwise, the invoice will be reported _and_ sent back to the sender!</p><p>        This field is only used for sending. We currently do not set this for receiving although that is on the roadmap.</p> +++
     * @return $this
     */
    public function setSelfBillingMode($self_billing_mode)
    {
        $this->container['self_billing_mode'] = $self_billing_mode;

        return $this;
    }

    /**
     * Gets sub_type
     *
     * @return string
     */
    public function getSubType()
    {
        return $this->container['sub_type'];
    }

    /**
     * Sets sub_type
     *
     * @param  string  $sub_type  The document subtype. Only used for received invoices, not for sending.
     * @return $this
     */
    public function setSubType($sub_type)
    {
        $allowedValues = $this->getSubTypeAllowableValues();
        if (! is_null($sub_type) && ! in_array($sub_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'sub_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sub_type'] = $sub_type;

        return $this;
    }

    /**
     * Gets tax_point_date
     *
     * @return string
     */
    public function getTaxPointDate()
    {
        return $this->container['tax_point_date'];
    }

    /**
     * Sets tax_point_date
     *
     * @param  string  $tax_point_date  The tax date is the date on which the supply of goods or of services was made or completed or the date on which the payment on account was made insofar as that date can be determined and differs from the date of the issue of the invoice. EU 2006-112 Article 226 Point 7. Note: For the Dutch TAX authorities the tac date should be the same as the issue date.
     * @return $this
     */
    public function setTaxPointDate($tax_point_date)
    {

        if (! is_null($tax_point_date) && (! preg_match('/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/', $tax_point_date))) {
            throw new \InvalidArgumentException("invalid value for $tax_point_date when calling Invoice., must conform to the pattern /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.");
        }

        $this->container['tax_point_date'] = $tax_point_date;

        return $this;
    }

    /**
     * Gets tax_subtotals
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\TaxSubtotal[]
     */
    public function getTaxSubtotals()
    {
        return $this->container['tax_subtotals'];
    }

    /**
     * Sets tax_subtotals
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\TaxSubtotal[]  $tax_subtotals  An array of tax subtotals. This element is mandatory for taxSystem 'tax_line_percentages'.
     * @return $this
     */
    public function setTaxSubtotals($tax_subtotals)
    {
        $this->container['tax_subtotals'] = $tax_subtotals;

        return $this;
    }

    /**
     * Gets tax_system
     *
     * @return string
     */
    public function getTaxSystem()
    {
        return $this->container['tax_system'];
    }

    /**
     * Sets tax_system
     *
     * @param  string  $tax_system  The tax system used for the invoice. The system 'tax_line_percentages' is preferred, but for historic purposes 'tax_line_amounts' is supported and the default. Since not all invoice formats that we are required to send support 'tax_line_amounts' we will need to convert the invoice to the 'tax_line_percentags' system if we are forced to send the invoice in that tax system. Note that an invoice must always contain tax information, even if that is 0% or an item or sender is exempt or tax is completely outside scope. In that case, use the correct tax categories (see <<_openapi_tax>>)
     * @return $this
     */
    public function setTaxSystem($tax_system)
    {
        $allowedValues = $this->getTaxSystemAllowableValues();
        if (! is_null($tax_system) && ! in_array($tax_system, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'tax_system', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tax_system'] = $tax_system;

        return $this;
    }

    /**
     * Gets taxes_duties_fees
     *
     * @return \Deegitalbe\LaravelTrustupIoStorecove\Model\Tax[]
     */
    public function getTaxesDutiesFees()
    {
        return $this->container['taxes_duties_fees'];
    }

    /**
     * Sets taxes_duties_fees
     *
     * @param  \Deegitalbe\LaravelTrustupIoStorecove\Model\Tax[]  $taxes_duties_fees  An array of taxes, duties and fees for this invoice. At this moment, the only invoice level tax allowed is the Italian '2 bollo virtuale'
     * @return $this
     */
    public function setTaxesDutiesFees($taxes_duties_fees)
    {
        $this->container['taxes_duties_fees'] = $taxes_duties_fees;

        return $this;
    }

    /**
     * Gets time_zone
     *
     * @return string
     */
    public function getTimeZone()
    {
        return $this->container['time_zone'];
    }

    /**
     * Sets time_zone
     *
     * @param  string  $time_zone  Format: zzzz, where zzzz is the difference from UTC, e.g. +0100 or -0900 etc. The timezone will also apply to the document issue date if this field is provided.
     * @return $this
     */
    public function setTimeZone($time_zone)
    {

        if (! is_null($time_zone) && (! preg_match('/^[+-]\\d{4}$/', $time_zone))) {
            throw new \InvalidArgumentException("invalid value for $time_zone when calling Invoice., must conform to the pattern /^[+-]\\d{4}$/.");
        }

        $this->container['time_zone'] = $time_zone;

        return $this;
    }

    /**
     * Gets transaction_type
     *
     * @return string
     */
    public function getTransactionType()
    {
        return $this->container['transaction_type'];
    }

    /**
     * Sets transaction_type
     *
     * @param  string  $transaction_type  The type of transaction. Currently used only for India.
     * @return $this
     */
    public function setTransactionType($transaction_type)
    {
        $allowedValues = $this->getTransactionTypeAllowableValues();
        if (! is_null($transaction_type) && ! in_array($transaction_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'transaction_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['transaction_type'] = $transaction_type;

        return $this;
    }

    /**
     * Gets ubl_extensions
     *
     * @return string[]
     */
    public function getUblExtensions()
    {
        return $this->container['ubl_extensions'];
    }

    /**
     * Sets ubl_extensions
     *
     * @param  string[]  $ubl_extensions  An array of ubl extensions.
     * @return $this
     */
    public function setUblExtensions($ubl_extensions)
    {
        $this->container['ubl_extensions'] = $ubl_extensions;

        return $this;
    }

    /**
     * Gets x2y
     *
     * @return string
     */
    public function getX2y()
    {
        return $this->container['x2y'];
    }

    /**
     * Sets x2y
     *
     * @param  string  $x2y  The type of entities the document is sent from/to: b2b (business-to-business), b2g (business-to-government) or b2c (business-to-consumer). This field does not have a default, but it in mose cases it will be treated as b2b. Only when you explicitly specify b2g or b2c OR when it is clear from the context will a different value be used. For instance, when we see the document is being routed to DE:LWID or NL:OINO number, this tells us it is b2g. But in many cases we are unable to determine this and so it is best to always specify this field. Note that b2b_sez is for use inside India only. This field is for sending only. Note that b2c_petty_cash (deprecated: petty_cash) is for use in Singapore only and is for reporting petty cash transactions in selfBillingMode. Also note that the categories b2c_point_of_sale and b2c_simplified_tax_invoice are for use in Singapore only and are for reporting point of sale transactions and simplified tax invoices respectively.
     * @return $this
     */
    public function setX2y($x2y)
    {
        $allowedValues = $this->getX2yAllowableValues();
        if (! is_null($x2y) && ! in_array($x2y, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'x2y', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['x2y'] = $x2y;

        return $this;
    }

    /**
     * Gets vat_reverse_charge
     *
     * @return bool
     */
    public function getVatReverseCharge()
    {
        return $this->container['vat_reverse_charge'];
    }

    /**
     * Sets vat_reverse_charge
     *
     * @param  bool  $vat_reverse_charge  DEPRECATED. Use taxExemptReason.
     * @return $this
     */
    public function setVatReverseCharge($vat_reverse_charge)
    {
        $this->container['vat_reverse_charge'] = $vat_reverse_charge;

        return $this;
    }

    /**
     * Gets tax_exempt_reason
     *
     * @return string
     */
    public function getTaxExemptReason()
    {
        return $this->container['tax_exempt_reason'];
    }

    /**
     * Sets tax_exempt_reason
     *
     * @param  string  $tax_exempt_reason  DEPRECATED. Use Tax/category and specify this per invoice line. If you do specify this field, it will be applied to all invoice lines and it is an error to specify a Tax/category at the invoice line level. This field holds the reason no tax is present in the invoice. Note that this is an invoice level field and you cannot specify it per invoice line. This field is mandatory unless tax is present in the invoice.
     * @return $this
     */
    public function setTaxExemptReason($tax_exempt_reason)
    {
        $allowedValues = $this->getTaxExemptReasonAllowableValues();
        if (! is_null($tax_exempt_reason) && ! in_array($tax_exempt_reason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'tax_exempt_reason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tax_exempt_reason'] = $tax_exempt_reason;

        return $this;
    }

    /**
     * Gets invoice_type
     *
     * @return string
     */
    public function getInvoiceType()
    {
        return $this->container['invoice_type'];
    }

    /**
     * Sets invoice_type
     *
     * @param  string  $invoice_type  DEPRECATED. Do not use. This field is available for legacy reasons only. If you want to send a regular invoice (aka UBL type '380'), make sure you have a positive invoice amount. For a credit note (aka UBL type '381'), simply provide a negative invoice amount. If you, in addition to a negative invoice amount, also specify a billingReferences, your invoice will become a corrective invoice (aka UBL type '384'). If your invoice is not sent in the UBL syntax, Storecove will provide the appropriate type for the syntax the invoice is sent in.
     * @return $this
     */
    public function setInvoiceType($invoice_type)
    {
        $allowedValues = $this->getInvoiceTypeAllowableValues();
        if (! is_null($invoice_type) && ! in_array($invoice_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'invoice_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['invoice_type'] = $invoice_type;

        return $this;
    }

    /**
     * Gets buyer_reference
     *
     * @return string
     */
    public function getBuyerReference()
    {
        return $this->container['buyer_reference'];
    }

    /**
     * Sets buyer_reference
     *
     * @param  string  $buyer_reference  DEPRECATED. Use a reference object with a documentType 'buyer_reference'. A reference provided by the buyer used for internal routing of the document.
     * @return $this
     */
    public function setBuyerReference($buyer_reference)
    {
        $this->container['buyer_reference'] = $buyer_reference;

        return $this;
    }

    /**
     * Gets order_reference
     *
     * @return string
     */
    public function getOrderReference()
    {
        return $this->container['order_reference'];
    }

    /**
     * Sets order_reference
     *
     * @param  string  $order_reference  DEPRECATED. Use a reference object with a documentType 'purchase_order'. A reference to an order for this invoice, assigned by the buyer. Note that this often is a key field, since many receivers of invoices will use this field to automatically match the invoice to an order they placed. Many receivers refuse invoices that cannot be automatically matched, in particular government agencies. So it is highly recommended to fill this field whenever possible.
     * @return $this
     */
    public function setOrderReference($order_reference)
    {
        $this->container['order_reference'] = $order_reference;

        return $this;
    }

    /**
     * Gets sales_order_id
     *
     * @return string
     */
    public function getSalesOrderId()
    {
        return $this->container['sales_order_id'];
    }

    /**
     * Sets sales_order_id
     *
     * @param  string  $sales_order_id  DEPRECATED. Use a reference object with a documentType 'sales_order'. A reference to an order for this invoice, assigned by the seller.
     * @return $this
     */
    public function setSalesOrderId($sales_order_id)
    {
        $this->container['sales_order_id'] = $sales_order_id;

        return $this;
    }

    /**
     * Gets billing_reference
     *
     * @return string
     */
    public function getBillingReference()
    {
        return $this->container['billing_reference'];
    }

    /**
     * Sets billing_reference
     *
     * @param  string  $billing_reference  DEPRECATED. Use a reference object with a documentType 'billing'. A reference to a commercial invoice or corrective invoice of which the current invoice is a correction. This field is mandatory when sending invoiceType 384.
     * @return $this
     */
    public function setBillingReference($billing_reference)
    {
        $this->container['billing_reference'] = $billing_reference;

        return $this;
    }

    /**
     * Gets contract_document_reference
     *
     * @return string
     */
    public function getContractDocumentReference()
    {
        return $this->container['contract_document_reference'];
    }

    /**
     * Sets contract_document_reference
     *
     * @param  string  $contract_document_reference  DEPRECATED. Use a reference object with a documentType 'contract'. A reference to a contract or framework agreement that this invoice relates to.
     * @return $this
     */
    public function setContractDocumentReference($contract_document_reference)
    {
        $this->container['contract_document_reference'] = $contract_document_reference;

        return $this;
    }

    /**
     * Gets project_reference
     *
     * @return string
     */
    public function getProjectReference()
    {
        return $this->container['project_reference'];
    }

    /**
     * Sets project_reference
     *
     * @param  string  $project_reference  DEPRECATED. Information about the project this invoice relates to.
     * @return $this
     */
    public function setProjectReference($project_reference)
    {
        $this->container['project_reference'] = $project_reference;

        return $this;
    }

    /**
     * Gets payment_means_iban
     *
     * @return string
     */
    public function getPaymentMeansIban()
    {
        return $this->container['payment_means_iban'];
    }

    /**
     * Sets payment_means_iban
     *
     * @param  string  $payment_means_iban  DEPRECATED. Use paymentMeansArray. The IBAN the amount payable should be transferred to
     * @return $this
     */
    public function setPaymentMeansIban($payment_means_iban)
    {
        $this->container['payment_means_iban'] = $payment_means_iban;

        return $this;
    }

    /**
     * Gets payment_means_bic
     *
     * @return string
     */
    public function getPaymentMeansBic()
    {
        return $this->container['payment_means_bic'];
    }

    /**
     * Sets payment_means_bic
     *
     * @param  string  $payment_means_bic  DEPRECATED. Use paymentMeansArray. The BIC (Swift) of the bank where the amount payable should be transferred to
     * @return $this
     */
    public function setPaymentMeansBic($payment_means_bic)
    {

        if (! is_null($payment_means_bic) && (! preg_match('/^[A-Z]{6}[2-9A-Z][0-9A-NP-Z]([A-Z0-9]{3}|X{3})?$/', $payment_means_bic))) {
            throw new \InvalidArgumentException("invalid value for $payment_means_bic when calling Invoice., must conform to the pattern /^[A-Z]{6}[2-9A-Z][0-9A-NP-Z]([A-Z0-9]{3}|X{3})?$/.");
        }

        $this->container['payment_means_bic'] = $payment_means_bic;

        return $this;
    }

    /**
     * Gets payment_means_code
     *
     * @return string
     */
    public function getPaymentMeansCode()
    {
        return $this->container['payment_means_code'];
    }

    /**
     * Sets payment_means_code
     *
     * @param  string  $payment_means_code  DEPRECATED. Use paymentMeansArray. How the invoice has been / will be paid. Use only online_payment_service (payment will be made or has been made by an online payment service), bank_card (e.g. debit card, credit card), direct_debit (the amount has been / will be taken out of the client's bank account), standing_agreement (an unspecified payment means known to both buyer and seller) or credit_transfer (the buyer will do / has done a bank transfer). The numeric codes are for legacy purposes, they should not be used.
     * @return $this
     */
    public function setPaymentMeansCode($payment_means_code)
    {
        $allowedValues = $this->getPaymentMeansCodeAllowableValues();
        if (! is_null($payment_means_code) && ! in_array($payment_means_code, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'payment_means_code', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_means_code'] = $payment_means_code;

        return $this;
    }

    /**
     * Gets payment_means_payment_id
     *
     * @return string
     */
    public function getPaymentMeansPaymentId()
    {
        return $this->container['payment_means_payment_id'];
    }

    /**
     * Sets payment_means_payment_id
     *
     * @param  string  $payment_means_payment_id  DEPRECATED. Use the paymentId in the individual PaymentMeans object. The payment id that you will use to match the payment against the invoice.
     * @return $this
     */
    public function setPaymentMeansPaymentId($payment_means_payment_id)
    {
        $this->container['payment_means_payment_id'] = $payment_means_payment_id;

        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param  int  $offset  Offset
     * @return bool
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param  int  $offset  Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param  int  $offset  Offset
     * @param  mixed  $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param  int  $offset  Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
